/**
 * Tests for API error handling improvements
 */

import { jest } from '@jest/globals';

// Mock UrlFetchApp
const mockUrlFetchApp = {
  fetch: jest.fn()
};

const mockResponse = {
  getResponseCode: jest.fn(),
  getContentText: jest.fn()
};

// Mock PropertiesService
const mockPropertiesService = {
  getUserProperties: jest.fn()
};

const mockUserProperties = {
  getProperty: jest.fn(),
  setProperty: jest.fn()
};

// Set up global mocks
(global as any).UrlFetchApp = mockUrlFetchApp;
(global as any).PropertiesService = mockPropertiesService;

// Mock config
jest.mock('../src/modules/config', () => ({
  Config: {
    GEMINI: {
      MODEL: 'gemini-2.5-flash',
      TEMPERATURE: 0.3,
      API_URL: 'https://generativelanguage.googleapis.com/v1beta/models/',
      TIMEOUT_MS: 30000
    }
  }
}));

// Mock error taxonomy
const mockErrorTaxonomy = {
  AppErrorType: {
    API_KEY_INVALID: 'API_KEY_INVALID',
    API_RATE_LIMITED: 'API_RATE_LIMITED',
    API_SERVICE_ERROR: 'API_SERVICE_ERROR',
    NETWORK_UNAVAILABLE: 'NETWORK_UNAVAILABLE'
  },
  createError: jest.fn(),
  logError: jest.fn(),
  parseError: jest.fn()
};

jest.mock('../src/modules/error-taxonomy', () => ({
  ErrorTaxonomy: mockErrorTaxonomy
}));

// Mock logger
jest.mock('../src/modules/logger', () => ({
  AppLogger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn()
  }
}));

// Import after mocks
let AI: any;

describe('API Error Handling Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    
    mockPropertiesService.getUserProperties.mockReturnValue(mockUserProperties);
    mockUrlFetchApp.fetch.mockReturnValue(mockResponse);
    
    // Reset error taxonomy mocks
    mockErrorTaxonomy.createError.mockImplementation((type: string, message: string, context: any) => ({
      type,
      message,
      context,
      toLogObject: () => ({ type, message, context })
    }));
    
    // Reimport to get fresh module
    jest.isolateModules(() => {
      AI = require('../src/modules/ai').AI;
    });
  });

  describe('callGemini error handling', () => {
    const testApiKey = 'test-api-key-123';
    const testPrompt = 'Test prompt';

    it('should handle 401 invalid API key with user-friendly message', () => {
      mockResponse.getResponseCode.mockReturnValue(401);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        error: {
          code: 401,
          message: 'API key not valid',
          status: 'UNAUTHENTICATED'
        }
      }));
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('❌ Invalid API key. Please check your Gemini API key in Settings.');
      expect(result.statusCode).toBe(401);
      
      // Should log error with API key masked
      expect(mockErrorTaxonomy.logError).toHaveBeenCalled();
      const errorCall = mockErrorTaxonomy.createError.mock.calls[0];
      expect(errorCall[2].url).toContain('key=***');
    });

    it('should handle 403 access denied with clear message', () => {
      mockResponse.getResponseCode.mockReturnValue(403);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        error: {
          code: 403,
          message: 'Permission denied',
          status: 'PERMISSION_DENIED'
        }
      }));
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('❌ Access denied. Your API key may not have the required permissions.');
      expect(result.statusCode).toBe(403);
    });

    it('should handle 429 rate limit with retry guidance', () => {
      mockResponse.getResponseCode.mockReturnValue(429);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        error: {
          code: 429,
          message: 'Resource exhausted',
          status: 'RESOURCE_EXHAUSTED'
        }
      }));
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('⏱️ Rate limit exceeded. Please wait a moment and try again.');
      expect(result.statusCode).toBe(429);
      expect(mockErrorTaxonomy.createError).toHaveBeenCalledWith(
        mockErrorTaxonomy.AppErrorType.API_RATE_LIMITED,
        expect.any(String),
        expect.any(Object)
      );
    });

    it('should handle 404 with manifest hint', () => {
      mockResponse.getResponseCode.mockReturnValue(404);
      mockResponse.getContentText.mockReturnValue('Not Found');
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('❌ API endpoint not found. This may be a configuration issue.');
      expect(result.statusCode).toBe(404);
    });

    it('should handle 500/503 service errors gracefully', () => {
      mockResponse.getResponseCode.mockReturnValue(503);
      mockResponse.getContentText.mockReturnValue('Service Unavailable');
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toBe('🔧 Gemini service is temporarily unavailable. Please try again later.');
      expect(result.statusCode).toBe(503);
      expect(mockErrorTaxonomy.createError).toHaveBeenCalledWith(
        mockErrorTaxonomy.AppErrorType.NETWORK_UNAVAILABLE,
        expect.any(String),
        expect.any(Object)
      );
    });

    it('should parse JSON error details when available', () => {
      mockResponse.getResponseCode.mockReturnValue(400);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        error: {
          code: 400,
          message: 'Invalid request: prompt too long',
          details: [{
            reason: 'PROMPT_TOO_LONG',
            metadata: { maxLength: 32000, actualLength: 35000 }
          }]
        }
      }));
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid request: prompt too long');
      expect(result.statusCode).toBe(400);
    });

    it('should handle non-JSON error responses', () => {
      mockResponse.getResponseCode.mockReturnValue(400);
      mockResponse.getContentText.mockReturnValue('Bad Request: Invalid syntax');
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Bad Request: Invalid syntax');
    });

    it('should handle successful response', () => {
      mockResponse.getResponseCode.mockReturnValue(200);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        candidates: [{
          content: {
            parts: [{
              text: 'AI response text'
            }]
          }
        }]
      }));
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(true);
      expect(result.text).toBe('AI response text');
      expect(result.error).toBeUndefined();
    });

    it('should handle timeout errors', () => {
      mockUrlFetchApp.fetch.mockImplementation(() => {
        throw new Error('Request timed out');
      });
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('timed out');
    });

    it('should handle network errors', () => {
      mockUrlFetchApp.fetch.mockImplementation(() => {
        throw new Error('Network connection failed');
      });
      
      const result = AI.callGemini(testApiKey, testPrompt);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Network connection failed');
    });
  });

  describe('API key in headers', () => {
    it('should send API key in x-goog-api-key header', () => {
      mockResponse.getResponseCode.mockReturnValue(200);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        candidates: [{ content: { parts: [{ text: 'test' }] } }]
      }));
      
      AI.callGemini('my-api-key', 'test prompt');
      
      expect(mockUrlFetchApp.fetch).toHaveBeenCalledWith(
        expect.stringContaining('generateContent'),
        expect.objectContaining({
          headers: {
            'x-goog-api-key': 'my-api-key'
          }
        })
      );
    });

    it('should NOT include API key in URL', () => {
      mockResponse.getResponseCode.mockReturnValue(200);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        candidates: [{ content: { parts: [{ text: 'test' }] } }]
      }));
      
      AI.callGemini('my-api-key', 'test prompt');
      
      const urlArg = mockUrlFetchApp.fetch.mock.calls[0][0];
      expect(urlArg).not.toContain('key=');
      expect(urlArg).not.toContain('my-api-key');
    });
  });

  describe('Welcome flow error handling', () => {
    it('should provide clear error for invalid API key during test', () => {
      mockResponse.getResponseCode.mockReturnValue(401);
      mockResponse.getContentText.mockReturnValue(JSON.stringify({
        error: { message: 'Invalid API key' }
      }));
      
      const result = AI.callGemini('bad-key', 'Classify this email');
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Invalid API key');
      expect(result.error).toContain('Settings');
    });

    it('should handle manifest whitelist errors', () => {
      mockUrlFetchApp.fetch.mockImplementation(() => {
        throw new Error('Request to https://generativelanguage.googleapis.com/... failed because the URL has not been whitelisted');
      });
      
      const result = AI.callGemini('key', 'prompt');
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('whitelisted');
    });
  });
});